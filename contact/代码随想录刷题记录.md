# 代码随想录刷题记录

## 二分查找

### 2024/7/6

### 69.X的平方根
https://leetcode.cn/problems/sqrtx/description/

#### 思路

二分查找，找的目标target就是targer x target偏小最接近输入x的那个，即整数部分然后因为是平方根，边界就是[0,x]，然后如果middle x middle 小于x也就是说平方根在右区间，左边界变化

```c++ 
class Solution {
public:
    int mySqrt(int x) {
        int l = 0;
        int r = x;
        int ans = 0;
        while(l<=r)
        {
            int middle = l + (r-l)/2;
            if((long long)middle * middle <=x)
            {
                ans = middle;//这里定答案是为了防止算出来平方根偏大1的问题
                l = middle+1;
            }
            else
            {
                r = middle - 1;
            }
        }
        return ans;
    }
};
```

## 移除元素

### 2024/7/6

### 26.删除有序数组中的重复项

https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/

#### 思路

采取快慢指针的方法，因为是删除重复项目，那令遍历从1开始然后当nums[i-1] != nums[i]时把nums[i]写到慢指针的所指处，然后更新慢指针即nums[slowindex++] = nums[i]，此处先赋值再加加,然后考虑到nums至少得有一个，slowindex初始值为1

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slowindex = 1;
        for(int i=1;i<nums.size();i++)
        {
            if(nums[i-1]!=nums[i])
            {
                nums[slowindex++] = nums[i];
            }
        }
        return slowindex;
    }
};
```

### 283.移动零

https://leetcode.cn/problems/move-zeroes/description/

#### 思路
和上一题差不多，也是快慢指针，不过这次target就是0了，然后需要在慢指针后面填充0回去

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slowindex = 0;
        for(int i = 0;i < nums.size();i++)
        {
            if(nums[i]!=0)
            {
                nums[slowindex++] = nums[i];
            }
        }
        for(int i = slowindex;i<nums.size();i++)
        {
            nums[i] = 0;
        }
    }
};
```

### 844.比较含退格的字符串

https://leetcode.cn/problems/backspace-string-compare/description/

#### 思路
也是快慢指针去处理target为‘#’的情况，不过因为要退格所以当快指针遇到‘#’时慢指针不但不加1还要倒退1,然后加上边界处理防止越界，再弹出多余的就行,两个字符串都处理一下然后比较就行

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        s = solve(s);
        t = solve(t);
        if(s == t)
            return true;
        else return false;
    }

    string solve(string s)
    {
        int slowindex = 0;
        for(int i = 0;i<s.size();i++)
        {
            if(s[i]!='#')
            {
                s[slowindex++] = s[i];
            }
            else{
                slowindex--;
                if(slowindex<0)
                    slowindex = 0;
            }
        }
        int length_old = s.size();
        for(int i = slowindex;i<length_old;i++)
        {
            s.pop_back();
        }
        return s;
    }
};
```

## 长度最小/大数组

一般使用滑动窗口的方法，滑动窗口的四个要素：1.起始序号 2.窗口长度 3.终止序号 4.滑动条件，先创建好四要素的变量，形成做题模范，确定窗口滑动的条件，然后开循环，循环里面递增的就是终止序号，然后按滑动条件去调整起始序号的变化，满足窗口长度要求

### 2024/7/8

### 904.水果成篮

https://leetcode.cn/problems/fruit-into-baskets/description/

#### 思路

最开始用纯滑动窗口，交上去只对了三分之一用例，后面抄官方用哈希表，哈希表确实方便，直接一一映射还能存数量，先抄着学习一下

```c++
//用例通过 37/91
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int sublength = 0,result=0,start = 0;
        for(int j = 0;j < fruits.size();j++)
        {
            if(sublength<2&&fruits[start]!=fruits[j])
            {
                sublength = j-start+1;
            }
            else if((fruits[j]==fruits[start]
                ||fruits[j]==fruits[start+1])
                )
            {
                sublength++;
            }
            else
            {
                start++;
            }
        }
        return sublength;
    }
};

//完全通过的哈希表解法
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int sublength = 0,start = 0,result = 0;
        unordered_map<int,int>cnt;
        for(int j = 0;j < fruits.size();j++)
        {
            cnt[fruits[j]]++;
            while(cnt.size()>2)
            {
                auto it = cnt.find(fruits[start]);
                it->second --;
                if(it->second == 0)
                {
                    cnt.erase(it);
                }
                start++;
            }
            result = max(result,j-start+1);
        }
        return result;
    }
};
```

## 顺时针打印数组/螺旋矩阵

这种题的要点一个是模拟过程，一个是对loop次数、endx、endy条件的计算，模拟过程的话倒还好，画几个图一般能有一个大致的模拟思路，重点在于流控条件的计算，比如loop次数、endx、endy这些，我感觉代码随想录这里讲的不好，用的例题太死板了是长宽相等的矩阵，剑指offer里面讲的比较好

>接下来分析循环结束条件,假设这个矩阵的行数是 rows, 列数columns。打印第一圈的左上角坐标是(0 0), 第二圈的左上角的坐标 (1，1) , 以此类推。我们注意到，左上角的坐标中行标和列标总是相同的，于是可以在矩阵中选取左上角为(start start)的一圈作为我们分析的目标
>
>对于一个5X5 矩阵而言，最后一圈只有一个数 ，对应的坐标为(2，2)我们发现5>2x2。对于一个6x6矩阵，最后一圈有4个数字，其左上角的坐标仍然为(2, 2) 发现 6>2x2仍然成立，于是可以得出，让循环继续的条件是columns>startX x 2并且rows>startY x 2。

![alt text](../images/image.png)

因为矩阵不再是长宽相等的矩阵，因此对是否打印/填入序列的判断相当重要，笔者就是因为没有对其进行判断导致写出来的代码只能通过3/25

```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int>result;
        int len_x = matrix[0].size();
        int len_y = matrix.size();
        int loop = max(len_y/2,len_x/2);
        int x=0,y=0,start=0;

    while(len_x>start*2 && len_y>start*2)
    {
        int endx = len_x - 1 - start;
        int endy = len_y - 1 -start;
        for(int i=start;i<=endx;i++)
        {
            result.push_back(matrix[start][i]);
        }
        if(start < endy)
        {
            for(int i=start+1;i<=endy;i++)
            {
                result.push_back(matrix[i][endx]);
            }
        }

        if(start < endx&&start<endy)
        {
            for(int i=endx-1;i>=start;i--)
            {
                result.push_back(matrix[endy][i]);
            }
        }

        if(start < endx&&start<endy-1)
        {
            for(int i=endy-1;i>=start+1;i--)
            {
                result.push_back(matrix[i][start]);
            }
        }

        start++;
    }
        return result;
    }
};
```